<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modifier reference - Proptest</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Usage documentation for the proptest and proptest-derive crates">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../proptest/index.html"><strong aria-hidden="true">1.</strong> proptest</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../proptest/getting-started.html"><strong aria-hidden="true">1.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/index.html"><strong aria-hidden="true">1.2.</strong> Understanding Proptest from the Bottom Up</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../proptest/tutorial/strategy-basics.html"><strong aria-hidden="true">1.2.1.</strong> Strategy Basics</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/shrinking-basics.html"><strong aria-hidden="true">1.2.2.</strong> Shrinking Basics</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/test-runner.html"><strong aria-hidden="true">1.2.3.</strong> Using the Test Runner</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/compound-strategies.html"><strong aria-hidden="true">1.2.4.</strong> Compound Strategies</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/macro-proptest.html"><strong aria-hidden="true">1.2.5.</strong> The proptest! macro</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/transforming-strategies.html"><strong aria-hidden="true">1.2.6.</strong> Transforming Strategies</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/macro-prop-compose.html"><strong aria-hidden="true">1.2.7.</strong> The prop_compose! macro</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/enums.html"><strong aria-hidden="true">1.2.8.</strong> Generating Enums</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/filtering.html"><strong aria-hidden="true">1.2.9.</strong> Filtering</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/recursive.html"><strong aria-hidden="true">1.2.10.</strong> Generating Recursive Data</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/higher-order.html"><strong aria-hidden="true">1.2.11.</strong> Higher-Order Strategies</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/arbitrary.html"><strong aria-hidden="true">1.2.12.</strong> Defining a Canonical Strategy for a Type</a></li><li class="chapter-item expanded "><a href="../proptest/tutorial/config.html"><strong aria-hidden="true">1.2.13.</strong> Configuring Proptest</a></li></ol></li><li class="chapter-item expanded "><a href="../proptest/failure-persistence.html"><strong aria-hidden="true">1.3.</strong> Failure Persistence</a></li><li class="chapter-item expanded "><a href="../proptest/forking.html"><strong aria-hidden="true">1.4.</strong> Test Timeouts and Forking</a></li><li class="chapter-item expanded "><a href="../proptest/no-std.html"><strong aria-hidden="true">1.5.</strong> no_std Support</a></li><li class="chapter-item expanded "><a href="../proptest/wasm.html"><strong aria-hidden="true">1.6.</strong> Web Assembly Support</a></li><li class="chapter-item expanded "><a href="../proptest/limitations.html"><strong aria-hidden="true">1.7.</strong> Limitations of Property Testing</a></li><li class="chapter-item expanded "><a href="../proptest/vs-quickcheck.html"><strong aria-hidden="true">1.8.</strong> Proptest vs Quickcheck</a></li><li class="chapter-item expanded "><a href="../proptest/reference-docs.html"><strong aria-hidden="true">1.9.</strong> Reference documentation</a></li><li class="chapter-item expanded "><a href="../proptest/state-machine.html"><strong aria-hidden="true">1.10.</strong> State Machine testing</a></li><li class="chapter-item expanded "><a href="../proptest/tips-and-best-practices.html"><strong aria-hidden="true">1.11.</strong> Tips and Best Practices</a></li></ol></li><li class="chapter-item expanded "><a href="../proptest-derive/index.html"><strong aria-hidden="true">2.</strong> proptest-derive</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../proptest-derive/getting-started.html"><strong aria-hidden="true">2.1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="../proptest-derive/modifiers.html" class="active"><strong aria-hidden="true">2.2.</strong> Modifier reference</a></li><li class="chapter-item expanded "><a href="../proptest-derive/errors.html"><strong aria-hidden="true">2.3.</strong> Error index</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Proptest</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="modifier-reference"><a class="header" href="#modifier-reference">Modifier Reference</a></h1>
<p>All modifiers interpreted by <code>#[derive(Arbitrary)]</code> are of the form
<code>#[proptest(..)]</code>, where the content between the parentheses follows the normal
Rust attribute syntax.</p>
<p>Each modifier within the parentheses is independent, in that putting two
modifiers in the same attribute is equivalent to having two <code>#[proptest(..)]</code>
attributes with one modifier each.</p>
<p>For brevity, modifiers are sometimes referenced by name alone; e.g., “the
<code>weight</code> modifier” refers to <code>#[proptest(weight = nn)]</code> and not some
freestanding <code>#[weight]</code> attribute.</p>
<h2 id="filter"><a class="header" href="#filter"><code>filter</code></a></h2>
<p>Form: <code>#[proptest(filter = F)]</code> or <code>#[proptest(filter(F))]</code> where <code>F</code> is either
a bare identifier (i.e., naming a function) or a Rust expression in a string.
In either case, the parameter must evaluate to something which is <code>Fn (&amp;T) -&gt; bool</code>, where <code>T</code> is the type of the item being filtered.</p>
<p>Usable on: structs, enums, enum variants, fields</p>
<p>The <code>filter</code> modifier allows filtering values generated for a field via
rejection sampling. Since rejection sampling is inefficient and interferes with
shrinking, it should only be used for conditions that are very rare or are
unfeasible to express otherwise. In many cases, <a href="#strategy"><code>strategy</code></a> can be
used to more directly express the desired behaviour without rejection sampling.
See the documentation for <a href="https://docs.rs/proptest/latest/proptest/strategy/trait.Strategy.html#method.prop_filter"><code>prop_filter</code></a> for more details.</p>
<p>The argument to the modifier must be a valid argument for the second parameter
of <a href="https://docs.rs/proptest/latest/proptest/strategy/trait.Strategy.html#method.prop_filter"><code>prop_filter</code></a>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::prelude::*;
</span>
#[derive(Debug, Arbitrary)]
#[proptest(filter = &quot;|segment| segment.start != segment.end&quot;)]
struct NonEmptySegment {
    start: i32,
    end: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>is equivalent to</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::prelude::*;
</span>
fn is_nonempty(segment: &amp;NonEmptySegment) -&gt; bool {
    segment.start != segment.end
}

#[derive(Debug, Arbitrary)]
#[proptest(filter = &quot;is_nonempty&quot;)]
struct NonEmptySegment {
    start: i32,
    end: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>As mentioned above, filtering should be avoided when it is reasonably possible
to express a non-filtering strategy that achieves the same effect. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::{proptest, arbitrary::any, strategy::Strategy};
</span>
#[derive(Debug, Arbitrary)]
struct BadExample {
    // Don't do this! Your tests will run more slowly and shrinking won't work
    // properly.
    #[proptest(filter = &quot;|x| x % 2 == 0&quot;)]
    even_number: u32,
}

#[derive(Debug, Arbitrary)]
struct GoodExample {
    // Directly generate even numbers only by transforming the set of all
    // `u32`s and then mapping it to the set of even `u32`s.
    #[proptest(strategy = &quot;any::&lt;u32&gt;().prop_map(|x| x / 2 * 2)&quot;)]
    even_number: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="no_bound"><a class="header" href="#no_bound"><code>no_bound</code></a></h2>
<p>Form: <code>#[proptest(no_bound)]</code></p>
<p>Usable on: generic type definitions and type parameters</p>
<p>Normally, when <code>#[derive(Arbitrary)]</code> is applied to an item with generic type
parameter, every type parameter which is “used” (see below) is required to
<code>impl Arbitrary</code>. For example, given a declaration like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">use proptest_derive::Arbitrary;
</span>
#[derive(Debug, Arbitrary)]
struct MyStruct&lt;T&gt; {
<span class="boring">    t: T
</span>    /* ... */
}
<span class="boring">}</span></code></pre></pre>
<p>Something like this will be generated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest::arbitrary::Arbitrary;
</span>
<span class="boring">#[derive(Debug)]
</span><span class="boring">struct MyStruct&lt;T&gt; {
</span><span class="boring">t: T
</span>}

impl&lt;T&gt; Arbitrary for MyStruct&lt;T&gt; where T: Arbitrary {
<span class="boring">    type Parameters = u32;
</span><span class="boring">    type Strategy = proptest::strategy::BoxedStrategy&lt;Self&gt;;
</span><span class="boring">    fn arbitrary_with(_params: Self::Parameters) -&gt; Self::Strategy { todo!() }
</span>    /* ... */
}
<span class="boring">}</span></code></pre></pre>
<p>Placing <code>#[proptest(no_bound)]</code> on a generic type definition is equivalent to
placing the same attribute on every type parameter.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::proptest;
</span><span class="boring">use std::marker::PhantomData;
</span>
#[derive(Debug, Arbitrary)]
#[proptest(no_bound)]
struct MyStruct&lt;A, B, C&gt; {
<span class="boring">    a: PhantomData&lt;A&gt;,
</span><span class="boring">    b: PhantomData&lt;B&gt;,
</span><span class="boring">    c: PhantomData&lt;C&gt;,
</span>    /* ... */
}
<span class="boring">}</span></code></pre></pre>
<p>This is equivalent to a hypothetical (but not currently supported) syntax like:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use std::marker::PhantomData;
</span>
#[derive(Debug, Arbitrary)]
struct MyStruct&lt;
  #[proptest(no_bound)] A,
  #[proptest(no_bound)] B,
  #[proptest(no_bound)] C,
&gt; {
<span class="boring">    a: PhantomData&lt;A&gt;,
</span><span class="boring">    b: PhantomData&lt;B&gt;,
</span><span class="boring">    c: PhantomData&lt;C&gt;,
</span>    /* ... */
}
<span class="boring">}</span></code></pre></pre>
<p>A type parameter is “used” if the following hold:</p>
<ul>
<li>
<p>The enum or struct definition references it at least once, and that reference
is not inside the type argument of a <code>PhantomData</code>.</p>
</li>
<li>
<p>The item referencing the type parameter does not have any proptest modifiers
which replace the usual use of <code>Arbitrary</code>, such as <a href="#skip"><code>skip</code></a> or
<a href="#value"><code>value</code></a>.</p>
</li>
</ul>
<p>Due to the above, <code>#[proptest(no_bound)]</code> is generally only needed when the
type parameter is used in another type which does not itself have an
<code>Arbitrary</code> bound on the type.</p>
<h2 id="no_params"><a class="header" href="#no_params"><code>no_params</code></a></h2>
<p>Form: <code>#[proptest(no_params)]</code></p>
<p>Usable on: structs, enums, enum variants, fields</p>
<p>On a struct or enum, <code>no_params</code> causes the <code>Arbitrary</code> parameter type to be
<code>()</code>. All automatic delegations to <code>Arbitrary</code> on members of the item use
<code>Default::default()</code> for their parameters.</p>
<p>On an enum variant or field, suppresses the addition of any parameter for the
variant or field to the parameters for the whole struct. If the variant or
field automatically delegates to <code>Arbitrary</code> for its value, that <code>Arbitrary</code>
call uses <code>Default::default()</code> for its own parameter.</p>
<p>See the <a href="#param"><code>param</code> modifier</a> for more information on how parameters work.</p>
<h2 id="params"><a class="header" href="#params"><code>params</code></a></h2>
<p>Form: <code>#[proptest(params = T)]</code> or <code>#[proptest(params(T))]</code>, where <code>T</code> is
either a bare identifier or Rust code inside a string. In either case, the
value must name a concrete Rust type which implements <code>Default</code>.</p>
<p>Usable on: structs, enums, enum variants, fields</p>
<p>The <a href="https://docs.rs/proptest/latest/proptest/arbitrary/trait.Arbitrary.html"><code>Arbitrary</code> trait</a> specifies a <code>Parameters</code> type which is used to control
generation. By default, the <code>Parameters</code> type is a tuple of the parameters
which are automatically passed to other <code>Arbitrary</code> implementations.</p>
<p>If applied to a struct or enum, <code>params</code> completely replaces the <code>Parameters</code>
type. Any automatic delegations to other <code>Arbitrary</code> implementations then use
<code>Default::default()</code> as there is no automatic way to locate an appropriate
value (if there even is any) within the <code>params</code> type.</p>
<p>If applied to an enum variant or field, <code>params</code> specifies the parameters type
for just that item, as if its type had an <code>Arbitrary</code> implementation taking
that type. In this case, either <a href="#value"><code>value</code></a> or <a href="#strategy"><code>strategy</code></a>
<em>must</em> be specified since the parameter type will not generally be compatible
with the normal <code>Arbitrary</code> invocation (and in cases where it is, <code>params</code>
would be useless if not used).</p>
<p>Any expressions (such as in the <a href="#value"><code>value</code></a> and <a href="#strategy"><code>strategy</code></a>
modifiers) underneath an item with the <code>params</code> modifier has access to a
variable named <code>params</code> which is of the type passed in
<code>#[proptest(params = ..)]</code>.</p>
<p>Examples:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::prelude::*;
</span>
#[derive(Debug)]
struct WidgetRange(usize, usize);

impl Default for WidgetRange {
    fn default() -&gt; Self { Self(0, 100) }
}

#[derive(Debug, Arbitrary)]
#[proptest(params(WidgetRange))]
struct WidgetCollection {
    #[proptest(strategy = &quot;params.0 ..= params.1&quot;)]
    desired_widget_count: usize,
    // ...
}

// ...

proptest! {
    #[test]
    fn test_something(wc in any_with::&lt;WidgetCollection&gt;(WidgetRange(10, 20))) {
        assert!(wc.desired_widget_count &gt;= 10 &amp;&amp; wc.desired_widget_count &lt;= 20);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="regex"><a class="header" href="#regex"><code>regex</code></a></h2>
<p>Form: <code>#[proptest(regex = &quot;string&quot;)]</code> or <code>#[proptest(regex(&quot;string&quot;))]</code>, where
<code>string</code> is a regular expression. May also be invoked as
<code>#[proptest(regex(function_name))]</code>, where <code>function_name</code> is a no-argument
function that returns an <code>&amp;'static str</code>.</p>
<p>Usable on: fields</p>
<p>This modifier specifies to generate character or byte strings for a field which
match a particular regular expression.</p>
<p>The <code>regex</code> modifier is equivalent to using the <a href="#strategy"><code>strategy</code></a> modifier and
enclosing the string in <a href="https://docs.rs/proptest/latest/proptest/string/fn.string_regex.html"><code>string_regex</code></a> or <a href="https://docs.rs/proptest/latest/proptest/string/fn.bytes_regex.html"><code>bytes_regex</code></a>. It can only be
applied to fields of type <code>String</code> or <code>Vec&lt;u8&gt;</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::proptest;
</span>#[derive(Debug, Arbitrary)]
struct FileContent {
    #[proptest(regex = &quot;[a-z0-9.]+&quot;)]
    name: String,
    #[proptest(regex = &quot;([0-9]+\n)*&quot;)]
    content: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="skip"><a class="header" href="#skip"><code>skip</code></a></h2>
<p>Form: <code>#[proptest(skip)]</code></p>
<p>Usable on: enum variants</p>
<p>Annotating an enum variant with <code>#[proptest(skip)]</code> prevents proptest from
generating that particular variant. This is useful when there is no sensible
way to generate the variant or when you want to temporarily stop generating
some variant during development.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::prelude::*;
</span>
#[derive(Debug, Arbitrary)]
enum DataSource {
    Memory(Vec&lt;u8&gt;),

    // There's no way to produce an &quot;arbitrary&quot; file handle, so we skip
    // generating this case.
    #[proptest(skip)]
    File(std::fs::File),
}
<span class="boring">}</span></code></pre></pre>
<p>It is an error to annotate all inhabited variants of an enum with
<code>#[proptest(skip)]</code> as this leaves proptest with no options to generate the
enum.</p>
<h2 id="strategy"><a class="header" href="#strategy"><code>strategy</code></a></h2>
<p>Form: <code>#[proptest(strategy = S)]</code> or <code>#[proptest(strategy = S)]</code>, where <code>S</code> is
either a string containing a Rust expression which evaluates to an appropriate
<code>Strategy</code>, or a bare identifier naming a function which, when called with no
arguments, returns such a <code>Strategy</code>.</p>
<p>Usable on: enum variants, fields</p>
<p>By default, enum variants are generated by recursing into their definition as
is done for struct declarations, and fields are generated by invoking
<code>Arbitrary</code> on the field type to produce a <code>Strategy</code>. The <code>strategy</code> modifier
allows to manually provide a custom strategy directly.</p>
<p>In the case of fields, the strategy must produce values of the same type as
that field. For enum variants, it must produce values of the enum type itself
and these values ought to be of the variant in question.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::prelude::*;
</span><span class="boring">use proptest::strategy::Strategy;
</span>
#[derive(Debug, Arbitrary)]
enum Token {
    Delimitation {
        // This field is still generated via Arbitrary
        delimiter: Delimiter,

        // But for this field we use a custom strategy
        #[proptest(strategy = &quot;1..(10 as u32)&quot;)]
        count: u32,

        // Here we also use a custom strategy, generated by the function
        // `offset_strategy`.
        #[proptest(strategy = &quot;offset_strategy()&quot;)]
        offset: u32,
    },

    // Specify how to generate the whole enum variant
    #[proptest(strategy = &quot;\&quot;[a-zA-Z]+\&quot;.prop_map(Token::Word)&quot;)]
    Word(String),
}

#[derive(Debug, Arbitrary)]
enum Delimiter {
<span class="boring">    Nope
</span>    /* ... */
 }

fn offset_strategy() -&gt; impl Strategy&lt;Value = u32&gt; {
  0..(100 as u32)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="value"><a class="header" href="#value"><code>value</code></a></h2>
<p>Form: <code>#[proptest(value = V)]</code> or <code>#[proptest(value(V))]</code>, where V can be: (a)
a Rust expression enclosed in a string; (b) another literal, or (c) a bare
identifier naming a no-argument function.</p>
<p>Usable on: enum variants, fields</p>
<p>The <code>value</code> modifier indicates that proptest should use the given expression or
function to produce a value for the field, instead of going through the usual
value generation machinery.</p>
<p>The argument to <code>value</code> is directly used as an expression for the field value
or enum variant to be generated, except that in the third form where it is a
bare identifier, it is called as a no-argument function to produce the value.</p>
<p>Using <code>value</code> is equivalent to using <a href="#strategy"><code>strategy</code></a> and enclosing the
value in <code>LazyJust</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::prelude::*;
</span><span class="boring">use std::time::Instant;
</span>
#[derive(Debug, Arbitrary)]
struct EventCounter {
    // We always start with the first two fields set to 0/None
    #[proptest(value = 0)]
    number_seen: u64,

    #[proptest(value = &quot;None&quot;)]
    last_seen_time: Option&lt;Instant&gt;,

    // This field is generated normally
    max_events: u64,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="weight"><a class="header" href="#weight"><code>weight</code></a></h2>
<p>Form: <code>#[proptest(weight = W)]</code> or <code>#[proptest(weight(W))]</code>, where <code>W</code> is an
expression evaluating to a <code>u32</code>. <code>weight</code> may also be abbreviated to <code>w</code>, as
in <code>#[proptest(w = W)]</code>.</p>
<p>Usable on: enum variants</p>
<p>The <code>weight</code> modifier determines how likely proptest is to generate a
particular enum variant. Weights are relative to each other; for example, a
<code>weight = 3</code> variant is 50% more likely to be generated than a <code>weight = 2</code>
variant and three times as likely to be generated as a <code>weight = 1</code> variant.</p>
<p>Variants with no <code>weight</code> modifier are equivalent to being annotated
<code>#[proptest(weight = 1)]</code>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate proptest_derive;
</span><span class="boring">extern crate proptest;
</span><span class="boring">use proptest_derive::Arbitrary;
</span><span class="boring">use proptest::proptest;
</span>#[derive(Debug, Arbitrary)]
enum FilterOption {
    KeepAll,
    DiscardAll,

    // This option is presumably harder for the code to handle correctly,
    // so we generate it more frequently than the other options.
    #[proptest(weight = 3)]
    OnlyMatching(String),
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../proptest-derive/getting-started.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../proptest-derive/errors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../proptest-derive/getting-started.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../proptest-derive/errors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
